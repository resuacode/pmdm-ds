import CodeBlock from '@theme/CodeBlock';

# Conexión a internet

## Corrutinas en Android

Las corutinas en Android son una forma de escribir código asíncrono de forma más sencilla y concisa. Las corutinas te permiten ejecutar tareas en segundo plano de forma eficiente y reactiva, sin bloquear el hilo principal de la aplicación. Las corutinas en Android se basan en el concepto de suspensión, que te permite pausar la ejecución de una tarea hasta que se complete una operación asíncrona, como una petición HTTP o una consulta a la base de datos.

Las corutinas en Android se utilizan principalmente para realizar operaciones asíncronas, como peticiones HTTP, consultas a la base de datos y operaciones de E/S. Las corutinas te permiten escribir código asíncrono de forma más sencilla y reactiva, sin tener que utilizar callbacks o interfaces de usuario complejas. Las corutinas en Android se basan en el concepto de suspensión, que te permite pausar la ejecución de una tarea hasta que se complete una operación asíncrona. 

Para implementar una clase que se ejecute en segundo plano debe crearse una suspend function, que es una función que puede pausar su ejecución. Para ello, se utiliza la palabra clave `suspend` antes de la declaración de la función. 

Por ejemplo, el siguiente código muestra un objeto que comienza un conteo en segundo plano y lo actualiza cada segundo:

```kotlin
object Timer {
    suspend fun start(callback: (Int) -> Unit) {
        var count = 0
        while (true) {
            delay(1000)
            count++
            callback(count)
        }
    }
}
```

En este ejemplo, la función `start` es una suspend function que inicia un conteo en segundo plano y llama a un callback cada segundo con el valor actual del contador. 

La función `delay` se utiliza para pausar la ejecución de la tarea durante un segundo.

Para llamar a una suspend function desde una función principal, se utiliza la función `runBlocking`, que crea un bloque de código que ejecuta la tarea de forma síncrona. Por ejemplo, el siguiente código muestra cómo llamar a la función `start` desde una función principal:

```kotlin
fun main() {
    runBlocking {
        Timer.start { count ->
            println("Count: $count")
        }
    }
}
```

En este ejemplo, la función `main` llama a la función `start` de forma síncrona utilizando `runBlocking`. La función `start` inicia un conteo en segundo plano y llama a un callback cada segundo con el valor actual del contador. 

Las corutinas en Android te permiten escribir código asíncrono de forma más sencilla y reactiva, sin tener que utilizar callbacks o interfaces de usuario complejas. Las corutinas se basan en el concepto de suspensión, que te permite pausar la ejecución de una tarea hasta que se complete una operación asíncrona.

![Corroutine Scope](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/a3c314fb082a9626_960.png?hl=es-419)

:::tip[La palabra clave suspend]
La palabra clave suspend en kotlin se utiliza para marcar una función que puede pausar su ejecución y reanudarla más tarde. Las funciones suspendidas se utilizan en las corutinas para realizar operaciones asíncronas de forma reactiva y eficiente.
:::

### LaunchedEffect para ejecutar tareas en segundo plano en Jetpack Compose

LaunchedEffect es una función de Jetpack Compose que te permite ejecutar una tarea en segundo plano cuando un composable se coloca en la jerarquía de composición.

Por ejemplo, el siguiente código muestra un composable que muestra un contador que se actualiza cada segundo:

```kotlin
@Composable
fun Timer() {
    var count by remember { mutableStateOf(0) }

    LaunchedEffect(Unit) {
        while (true) {
            delay(1000)
            count++
        }
    }

    Text(text = "Count: $count")
}
```

En este ejemplo, el composable `Timer` muestra un contador que se actualiza cada segundo. La función `LaunchedEffect` se utiliza para iniciar un bucle infinito que actualiza el contador cada segundo. La función `delay` se utiliza para pausar la ejecución del bucle durante un segundo.    

### Alcance de las corutinas en Jetpack Compose

En Jetpack Compose, las corutinas se ejecutan en el alcance de un composable, lo que significa que una corutina se cancela automáticamente cuando el composable se elimina de la jerarquía de composición. Esto garantiza que las corutinas se cancelen de forma segura y eficiente cuando ya no son necesarias, evitando posibles fugas de memoria y problemas de rendimiento. 

Por ejemplo, el siguiente código muestra un composable que inicia una corutina cuando se coloca en la jerarquía de composición y la cancela cuando se elimina:

```kotlin 
@Composable
fun Timer() {
    var count by remember { mutableStateOf(0) }

    LaunchedEffect(Unit) {
        while (true) {
            delay(1000)
            count++
        }
    }

    DisposableEffect(Unit) {
        onDispose {
            // Cancela la corutina cuando el composable se elimina
            coroutineContext.cancel()
        }
    }

    Text(text = "Count: $count")
}
``` 

En este ejemplo, el composable `Timer` inicia una corutina cuando se coloca en la jerarquía de composición utilizando `LaunchedEffect` y la cancela cuando se elimina utilizando `DisposableEffect`. La función `onDispose` se utiliza para realizar tareas de limpieza cuando el composable se elimina, como cancelar la corutina.

### CoroutineScope en Jetpack Compose

En Jetpack Compose, puedes utilizar `coroutineScope` para crear un alcance de corutina que se cancela automáticamente cuando el composable se elimina de la jerarquía de composición. `coroutineScope` es una función de Jetpack Compose que te permite crear un alcance de corutina local que se cancela automáticamente cuando el composable se elimina.  

Por ejemplo, el siguiente código muestra un composable que inicia una corutina utilizando `coroutineScope` y la cancela cuando se elimina:

```kotlin
@Composable
fun Timer() {
    var count by remember { mutableStateOf(0) }

    coroutineScope {
        launch {
            while (true) {
                delay(1000)
                count++
            }
        }
    }

    Text(text = "Count: $count")
}
``` 

En este ejemplo, el composable `Timer` inicia una corutina utilizando `coroutineScope` y la cancela automáticamente cuando el composable se elimina. La función `launch` se utiliza para iniciar una corutina en el alcance de `coroutineScope` que actualiza el contador cada segundo. 

`coroutineScope` es una función de Jetpack Compose que te permite crear un alcance de corutina local que se cancela automáticamente cuando el composable se elimina. `coroutineScope` es útil para iniciar corutinas en un composable y garantizar que se cancelen de forma segura y eficiente cuando ya no son necesarias. 

### CoroutineScope en un LaunchedEffect

En Jetpack Compose, puedes utilizar `coroutineScope` en un `LaunchedEffect` para crear un alcance de corutina local que se cancela automáticamente cuando el composable se elimina de la jerarquía de composición. `coroutineScope` es una función de Jetpack Compose que te permite crear un alcance de corutina local que se cancela automáticamente cuando el composable se elimina. 

Por ejemplo, el siguiente código muestra un composable que inicia una corutina utilizando `coroutineScope` en un `LaunchedEffect` y la cancela cuando se elimina:

```kotlin
@Composable
fun Timer() {
    var count by remember { mutableStateOf(0) }

    LaunchedEffect(Unit) {
        coroutineScope {
            launch {
                while (true) {
                    delay(1000)
                    count++
                }
            }
        }
    }

    Text(text = "Count: $count")
}
``` 

En este ejemplo, el composable `Timer` inicia una corutina utilizando `coroutineScope` en un `LaunchedEffect` y la cancela automáticamente cuando el composable se elimina. La función `launch` se utiliza para iniciar una corutina en el alcance de `coroutineScope` que actualiza el contador cada segundo.  

`coroutineScope` es una función de Jetpack Compose que te permite crear un alcance de corutina local que se cancela automáticamente cuando el composable se elimina. `coroutineScope` es útil para iniciar corutinas en un composable y garantizar que se cancelen de forma segura y eficiente cuando ya no son necesarias. 

Un ejemplo de uso podemos encontrarlo en el siguiente Codelab en el que se implemmenta una carrera ficticia entre dos jugadores:

[Codelab: Carrera de coches ficticia](https://developer.android.com/codelabs/basic-android-kotlin-compose-coroutines-android-studio?hl=es-419&continue=https%3A%2F%2Fdeveloper.android.com%2Fcourses%2Fpathways%2Fandroid-basics-compose-unit-5-pathway-1%3Fhl%3Des-419%23codelab-https%3A%2F%2Fdeveloper.android.com%2Fcodelabs%2Fbasic-android-kotlin-compose-coroutines-android-studio)

:::info[CoroutineContext]
El contexto de la corrutina es un objeto que proporciona información sobre la corutina, como su alcance, su trabajo y su estado. El contexto de la corutina se utiliza para gestionar la ejecución de la corutina y proporcionar información sobre su estado y progreso.
:::

:::tip[LaunchedEffect]
LaunchedEffect es una función de Jetpack Compose que te permite ejecutar una tarea en segundo plano cuando un composable se coloca en la jerarquía de composición. LaunchedEffect es útil para realizar operaciones asíncronas, como peticiones HTTP, consultas a la base de datos y operaciones de E/S.

Una de las principales ventajas del uso de LaunchedEffect es que se ejecuta en el alcance de un composable, lo que significa que se cancela automáticamente cuando el composable se elimina de la jerarquía de composición. Esto garantiza que las tareas en segundo plano se cancelen de forma segura y eficiente cuando ya no son necesarias, evitando posibles fugas de memoria y problemas de rendimiento.
Esto hace que no sea necesario preocuparse por la cancelación manual de las tareas en segundo plano, ya que Jetpack Compose se encarga de ello de forma automática. 
Tampoco debemos preocuparnos de proporcionar un componente Dispatcher de forma explícita, ya que LaunchedEffect utiliza el Dispatcher predeterminado de la corrutina para ejecutar la tarea en segundo plano. 
:::

## Formas de conectarse a internet desde uaa app

Para conectarse a internet en una aplicación Android con Jetpack Compose, puedes utilizar las siguientes opciones:  

- **Retrofit**: Retrofit es una biblioteca de cliente HTTP para Android y Java que facilita la conexión a servicios web RESTful. Puedes utilizar Retrofit para realizar peticiones HTTP a un servidor y obtener los datos necesarios para tu aplicación.

- **Ktor**: Ktor es un framework de cliente y servidor web en Kotlin que te permite crear aplicaciones web

- **Volley**: Volley es una biblioteca de red que facilita la conexión a servicios web en Android. Puedes utilizar Volley para realizar peticiones HTTP y gestionar las respuestas de forma sencilla.

Vamos a centrarnos en la primera opción, Retrofit, que es una de las bibliotecas más utilizadas para conectarse a servicios web en Android. 

![DataLayer](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/76551dbe9fc943aa_960.png?hl=es-419)

## ¿Qué es Retrofit?

Retrofit es una biblioteca de cliente HTTP para Android y Java que facilita la conexión a servicios web RESTful. Retrofit te permite definir una interfaz de servicio web con anotaciones que describen las operaciones disponibles en el servicio, como las peticiones GET, POST, PUT y DELETE. Retrofit se encarga de convertir las respuestas del servidor en objetos Java/Kotlin y de gestionar la comunicación con el servidor de forma eficiente.

![Ejemplo de Petición http](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/301162f0dca12fcf_960.png)
![Ejemplo de respuesta http](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/7ced9b4ca9c65af3_960.png)

:::info[Tipos de peticiones habituales HTTP]
- **GET**: Se utiliza para obtener datos del servidor. Por ejemplo, puedes utilizar una petición GET para obtener una lista de usuarios de un servidor.
- **POST**: Se utiliza para enviar datos al servidor. Por ejemplo, puedes utilizar una petición POST para enviar un formulario con los datos de un nuevo usuario al servidor.
- **PUT**: Se utiliza para actualizar datos en el servidor. Por ejemplo, puedes utilizar una petición PUT para actualizar los datos de un usuario existente en el servidor.
- **DELETE**: Se utiliza para eliminar datos del servidor. Por ejemplo, puedes utilizar una petición DELETE para eliminar un usuario del servidor.

![Ejemplo de petición http](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/5bbeef4ded3e84cf_960.png)
![Ejemplo de respuesta http](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/83e8a6eb79249ebe_960.png)
:::

## Implementación de Retrofit en Jetpack Compose

Para implementar Retrofit en una aplicación Android con Jetpack Compose, puedes seguir los siguientes pasos:

1. **Definir la interfaz de servicio web**: Define una interfaz que contenga las operaciones disponibles en el servicio web y anótala con las anotaciones de Retrofit, como `@GET`, `@POST`, `@PUT` y `@DELETE`. Por ejemplo, puedes definir una interfaz `ApiService` que contenga métodos para obtener y enviar datos al servidor.

2. **Crear una instancia de Retrofit**: Crea una instancia de Retrofit utilizando el constructor de `Retrofit.Builder` y configura la URL base del servicio web y el convertidor de JSON. Por ejemplo, puedes crear una instancia de Retrofit que se conecte a un servidor en `https://api.example.com` y utilice el convertidor de JSON de Gson.

3. **Crear una instancia del servicio web**: Crea una instancia del servicio web a partir de la interfaz de servicio web y la instancia de Retrofit. Por ejemplo, puedes crear una instancia del servicio web a partir de la interfaz `ApiService` y la instancia de Retrofit.

4. **Realizar peticiones HTTP**: Utiliza la instancia del servicio web para realizar peticiones HTTP al servidor y obtener los datos necesarios para tu aplicación. Por ejemplo, puedes utilizar el método `getUsers()` de la interfaz `ApiService` para obtener una lista de usuarios del servidor.

![Funcionamiento Retrofit](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/26043df178401c6a_960.png)

## Ejemplo de implementación

A continuación, se muestra un ejemplo de implementación de Retrofit en una aplicación Android con Jetpack Compose:

```kotlin
// Define la interfaz de servicio web con las operaciones disponibles
interface ApiService {
    @GET("users")
    suspend fun getUsers(): List<User>
}

// Crea una instancia de Retrofit con la URL base y el convertidor de JSON
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com")
    .addConverterFactory(GsonConverterFactory.create())
    .build()

// Crea una instancia del servicio web a partir de la interfaz de servicio web y la instancia de Retrofit
val apiService = retrofit.create(ApiService::class.java)

// Realiza una petición HTTP al servidor para obtener una lista de usuarios
val users = apiService.getUsers()
```

En este ejemplo, se define una interfaz `ApiService` con el método `getUsers()` que realiza una petición GET al servidor para obtener una lista de usuarios. Se crea una instancia de Retrofit con la URL base `https://api.example.com` y el convertidor de JSON de Gson. A continuación, se crea una instancia del servicio web a partir de la interfaz `ApiService` y la instancia de Retrofit. Por último, se utiliza la instancia del servicio web para realizar una petición HTTP al servidor y obtener una lista de usuarios.    

Con Retrofit, puedes conectarte a servicios web RESTful de forma sencilla y eficiente en una aplicación Android con Jetpack Compose. Retrofit te permite definir una interfaz de servicio web con anotaciones que describen las operaciones disponibles en el servicio y gestionar la comunicación con el servidor de forma automática. 

Todo este código suele ordenarse y distribuirse en diferentes archivos y paquetes para mantener una estructura limpia y organizada. A continuación veremos cada uno de estos pasos en detalle.  

## Implementación de Retrofit en Android

### Importar las dependencias de Retrofit

Para utilizar Retrofit en una aplicación Android, primero debes importar las dependencias de Retrofit en el archivo `build.gradle` del módulo de la aplicación. Puedes hacerlo añadiendo las siguientes líneas al archivo `build.gradle`:

```kotlin
dependencies {
    // Retrofit
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    // Retrofit with Scalar Converter
    implementation("com.squareup.retrofit2:converter-scalars:2.9.0")
}
```

Estas líneas importan las dependencias de Retrofit y el convertidor de escalares en la aplicación. El convertidor de escalares se utiliza para convertir las respuestas del servidor en cadenas de texto.

### Definir la interfaz de servicio web

A continuación, debes definir una interfaz de servicio web que contenga las operaciones disponibles en el servicio. 
Puedes hacerlo creando una interfaz en un archivo Kotlin y anotándola con las anotaciones de Retrofit, como `@GET`, `@POST`, `@PUT` y `@DELETE`. 
Por ejemplo, puedes definir una interfaz `ApiService` que contenga métodos para obtener y enviar datos al servidor:

```kotlin
import retrofit2.http.GET

interface ApiService {
    @GET("users")
    suspend fun getUsers(): List<User>
}
```

En este ejemplo, la interfaz `ApiService` contiene un método `getUsers()` que realiza una petición GET al servidor para obtener una lista de usuarios.

:::tip[Ubicación de la interfaz de servicio web en el proyecto]
La interfaz de servicio web suele ubicarse en un paquete de datos, network o servicios del proyecto para mantener una estructura limpia y organizada.
:::

:::info[Anotaciones de Retrofit]
Las anotaciones de Retrofit se utilizan para describir las operaciones disponibles en el servicio web. Por ejemplo, la anotación `@GET` se utiliza para realizar una petición GET al servidor, la anotación `@POST` se utiliza para realizar una petición POST al servidor, y así sucesivamente.    
:::

### Crear una instancia de Retrofit

Una vez que hayas definido la interfaz de servicio web, debes crear una instancia de Retrofit utilizando el constructor de `Retrofit.Builder`.
Puedes hacerlo creando una instancia de Retrofit en un archivo Kotlin y configurando la URL base del servicio web y el convertidor de JSON.
Por ejemplo, puedes crear una instancia de Retrofit que se conecte a un servidor en `https://api.example.com` y utilice el convertidor de JSON de Gson:

```kotlin
private const val BASE_URL = "https://api.example.com"

val retrofit = Retrofit.Builder()
    .baseUrl(BASE_URL)
    .addConverterFactory(GsonConverterFactory.create())
    .build()
```

:::warning[Para usar Gson en tu proyecto]
Para utilizar Gson en tu proyecto, debes importar la dependencia de Gson en el archivo `build.gradle` del módulo de la aplicación. Puedes hacerlo añadiendo la siguiente línea al archivo `build.gradle`:

```kotlin
dependencies {
    // Gson
    implementation("com.google.code.gson:gson:2.8.8")
}
```
:::

En este ejemplo, se crea una instancia de Retrofit con la URL base `https://api.example.com` y el convertidor de JSON de Gson.

:::tip[Ubicación de la instancia de Retrofit en el proyecto]
La instancia de Retrofit suele ubicarse en un archivo Kotlin en el paquete de datos, network o servicios del proyecto para mantener una estructura limpia y organizada.
:::

:::tip[Convertidores de Retrofit]
Retrofit utiliza convertidores para convertir las respuestas del servidor en objetos Java/Kotlin y viceversa. 
Puedes utilizar convertidores como Gson, Moshi, Jackson y Scalars para convertir los datos del servidor en objetos Java/Kotlin y viceversa.   
Cada uno de estos convertidores tiene sus propias ventajas y desventajas, por lo que debes elegir el que mejor se adapte a tus necesidades.
En este ejemplo, se utiliza el convertidor de Gson para convertir los datos del servidor en objetos Java/Kotlin. 
Sin embargo, si prefieres utilizar otro convertidor, puedes cambiar el convertidor de Gson por el convertidor de tu elección.
Por ejemplo, para hacer el mismo ejemplo anterior pero usando Scalars, puedes cambiar la línea de configuración del convertidor de Gson por la siguiente:

```kotlin
.addConverterFactory(ScalarsConverterFactory.create())
```
:::

### Crear una instancia del servicio web

Una vez que hayas creado una instancia de Retrofit, debes crear una instancia del servicio web a partir de la interfaz de servicio web y la instancia de Retrofit.
Puedes hacerlo creando una instancia del servicio web en un archivo Kotlin y utilizando el método `create()` de Retrofit.
Por ejemplo, puedes crear una instancia del servicio web a partir de la interfaz `ApiService` y la instancia de Retrofit:

```kotlin
val apiService = retrofit.create(ApiService::class.java)
```

En este ejemplo, se crea una instancia del servicio web a partir de la interfaz `ApiService` y la instancia de Retrofit.

Esta instancia suele implementarse a través de un patrón Singleton para garantizar que solo haya una instancia del servicio web en la aplicación, sin embargo, esto dependerá de las necesidades de tu aplicación.
En muchas ocasiones es preferible utilizar inyección de dependencias para proporcionar instancias de servicios web en lugar de crearlas manualmente. 
De esta forma los objetos se pueden reutilizar y se facilita la gestión de dependencias en la aplicación.

Esto se debe a que los Singleton representan estados globales en la aplicación y pueden ser difíciles de gestionar y probar. 
Por otro lado, la inyección de dependencias permite desacoplar las dependencias de los objetos y facilita la gestión de las dependencias en la aplicación.

Vamos a acostumbrarnos a gestionar las dependencias de esta forma, ya que es una buena práctica de programación y facilita la gestión de dependencias en la aplicación.





## Recursos


